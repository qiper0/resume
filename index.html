<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown编辑器</title>
    <style>
        /* 基础重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            padding: 0;
        }
        
        /* 编辑模式容器 */
        .editor-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: 100vh;
            gap: 1px;
            background: #ddd;
        }
        
        @media (max-width: 768px) {
            .editor-container {
                grid-template-columns: 1fr;
            }
        }
        
        /* 文本编辑区域 */
        .editor-area {
            background: white;
            padding: 20px;
            overflow-y: auto;
        }
        
        #editor {
            width: 100%;
            height: calc(100vh - 40px);
            border: none;
            resize: none;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
            padding: 0;
        }
        
        /* 预览区域 */
        .preview-area {
            background: white;
            padding: 1em;
            overflow-y: auto;
        }
        
        /* 只读预览模式 */
        .view-only {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            background: white;
            min-height: 100vh;
        }
        
        /* Markdown 样式 - 简洁专业 */
        .markdown-content {
            font-size: 1em;
            line-height: 1.8;
        }
        
        .markdown-content h1 {
            font-size: 2em;
            margin: 1em 0 0.5em 0;
            color: #2c3e50;
            padding-bottom: 0.3em;
            border-bottom: 2px solid #eee;
        }
        
        .markdown-content h2 {
            font-size: 1.5em;
            margin: 1.5em 0 0.5em 0;
            color: #2c3e50;
            padding-bottom: 0.3em;
            border-bottom: 1px solid #eee;
        }
        
        .markdown-content h3 {
            font-size: 1.2em;
            margin: 1.2em 0 0.5em 0;
            color: #2c3e50;
        }
        
        .markdown-content h4 {
            font-size: 1.1em;
            margin: 1.1em 0 0.5em 0;
            color: #2c3e50;
        }
        
        .markdown-content h5 {
            font-size: 1em;
            margin: 1em 0 0.5em 0;
            color: #2c3e50;
        }
        
        .markdown-content h6 {
            font-size: 0.9em;
            margin: 0.9em 0 0.5em 0;
            color: #2c3e50;
        }
        
        .markdown-content p {
            margin: 1em 0;
        }
        
        .markdown-content ul, .markdown-content ol {
            margin: 1em 0;
            padding-left: 2em;
        }
        
        .markdown-content li {
            margin: 0.5em 0;
        }
        
        .markdown-content strong {
            color: #2c3e50;
            font-weight: 600;
        }
        
        .markdown-content em {
            color: #555;
        }
        
        .markdown-content blockquote {
            border-left: 4px solid #4a6fa5;
            padding: 0.5em 1em;
            margin: 1em 0;
            background: #f8f9fa;
            color: #555;
        }
        
        .markdown-content code {
            background: #f1f3f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.9em;
        }
        
        .markdown-content pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1em;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1em 0;
        }
        
        .markdown-content pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        
        /* 表格样式 */
        .markdown-content table {
            border-collapse: collapse;
            margin: 1em 0;
            width: 100%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .markdown-content table th,
        .markdown-content table td {
            border: 1px solid #e1e4e8;
            padding: 0.75em 1em;
            text-align: left;
        }
        
        .markdown-content table th {
            background: #f6f8fa;
            font-weight: 600;
            color: #24292e;
        }
        
        .markdown-content table tr:nth-child(even) {
            background-color: #fafbfc;
        }
        
        .markdown-content table tr:hover {
            background-color: #f6f8fa;
        }
        
        /* 任务列表样式 */
        .markdown-content .task-list-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5em;
        }
        
        .markdown-content .task-list-item input[type="checkbox"] {
            margin-top: 0.3em;
        }
        
        .markdown-content .task-list-item input[type="checkbox"]:checked + span {
            text-decoration: line-through;
            color: #6a737d;
        }
        
        /* 删除线样式 */
        .markdown-content del {
            text-decoration: line-through;
            color: #6a737d;
            background-color: #ffeef0;
            padding: 0 0.2em;
            border-radius: 2px;
        }
        
        /* 图片样式 */
        .markdown-content img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 1em 0;
        }
        
        /* 链接样式 */
        .markdown-content a {
            color: #0366d6;
            text-decoration: none;
            border-bottom: 1px solid rgba(3, 102, 214, 0.2);
            transition: all 0.2s ease;
        }
        
        .markdown-content a:hover {
            color: #0056b3;
            border-bottom-color: #0366d6;
        }
        
        /* 水平线样式 */
        .markdown-content hr {
            border: none;
            border-top: 2px solid #eaecef;
            margin: 2.5em auto;
            width: 80%;
        }
        
        /* 状态提示（自动保存时显示） */
        .save-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(74, 111, 165, 0.9);
            color: white;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .save-status.show {
            opacity: 1;
        }
        
        /* 隐藏所有元素 */
        .hidden {
            display: none !important;
        }
        
        /* 加载中样式 */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            color: #666;
        }
    </style>
</head>
<body>
    <!-- 编辑模式 -->
    <div id="editMode" class="editor-container hidden">
        <div class="editor-area">
            <textarea id="editor" placeholder="在这里编辑Markdown文档..."></textarea>
        </div>
        <div class="preview-area">
            <div id="preview" class="markdown-content"></div>
        </div>
    </div>
    
    <!-- 只读预览模式 -->
    <div id="viewMode" class="view-only hidden">
        <div id="viewContent" class="markdown-content"></div>
    </div>
    
    <!-- 自动保存状态提示 -->
    <div id="saveStatus" class="save-status">已保存</div>

    <script>
        // 核心变量
        let saveTimer = null;
        let currentContent = '';
        let isEditing = false;
        let currentFile = '';
        
        // HTML转义
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 处理行内Markdown语法
        function processInlineMarkdown(text) {
            if (!text) return '';
            
            let result = text;
            
            // 处理加粗和斜体（注意顺序：先处理三个，再处理两个，再处理一个）
            result = result.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            result = result.replace(/___(.*?)___/g, '<strong><em>$1</em></strong>');
            
            result = result.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            result = result.replace(/__(.*?)__/g, '<strong>$1</strong>');
            
            result = result.replace(/\*(.*?)\*/g, '<em>$1</em>');
            result = result.replace(/_(.*?)_/g, '<em>$1</em>');
            
            // 处理删除线
            result = result.replace(/~~(.*?)~~/g, '<del>$1</del>');
            
            // 处理行内代码
            result = result.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // 处理链接 [text](url "title")
            result = result.replace(/\[([^\]]+)\]\(([^)"]+)(?:\s+"([^"]+)")?\)/g, 
                (match, text, url, title) => {
                    const titleAttr = title ? ` title="${title}"` : '';
                    return `<a href="${url}"${titleAttr} target="_blank">${text}</a>`;
                });
            
            // 处理图片 ![alt](src "title")
            result = result.replace(/!\[([^\]]*)\]\(([^)"]+)(?:\s+"([^"]+)")?\)/g, 
                (match, alt, src, title) => {
                    const titleAttr = title ? ` title="${title}"` : '';
                    return `<img src="${src}" alt="${alt}"${titleAttr}>`;
                });
            
            // 处理自动链接 <url>
            result = result.replace(/<([^>]+)>/g, (match, url) => {
                if (url.match(/^https?:\/\//)) {
                    return `<a href="${url}" target="_blank">${url}</a>`;
                } else if (url.match(/^mailto:/)) {
                    return `<a href="${url}">${url.substring(7)}</a>`;
                }
                return match;
            });
            
            // 处理邮箱地址
            result = result.replace(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g, 
                '<a href="mailto:$1">$1</a>');
            
            return result;
        }
        
        // 增强的Markdown解析器
        function parseMarkdown(text) {
            if (!text) return '';
            
            // 1. 处理代码块（先处理，避免内部内容被解析）
            let html = text;
            
            // 处理围栏代码块 ```
            html = html.replace(/```([\s\S]*?)```/g, (match, code) => {
                // 检测语言类型
                const lines = code.trim().split('\n');
                let language = '';
                let codeContent = code;
                
                // 检查第一行是否是语言声明
                if (lines[0].match(/^[a-zA-Z0-9+#-]+$/)) {
                    language = lines[0].trim();
                    codeContent = lines.slice(1).join('\n').trim();
                }
                
                return `<pre><code class="language-${language}">${escapeHtml(codeContent)}</code></pre>`;
            });
            
            // 处理缩进代码块
            html = html.replace(/^( {4,}|\t+)(.*)$/gm, (match, indent, line) => {
                return '<code>' + escapeHtml(line) + '</code>';
            });
            
            // 2. 处理表格
            html = html.replace(/^\|(.+)\|$/gm, (match, row) => {
                return match; // 先标记，稍后处理整个表格
            });
            
            // 实际表格处理
            html = html.replace(/((?:\|.*\|(?:\r?\n|$))+)/g, (match) => {
                const lines = match.trim().split('\n');
                if (lines.length < 2) return match; // 不是表格
                
                const rows = lines.map(line => {
                    // 清理行首尾的管道符
                    const cleanLine = line.trim().replace(/^\||\|$/g, '');
                    return cleanLine.split('|').map(cell => cell.trim());
                });
                
                // 检查是否有表头分隔线
                const hasHeaderSeparator = rows.length > 1 && 
                    rows[1].every(cell => cell.replace(/[-:]/g, '').trim() === '');
                
                if (hasHeaderSeparator && rows.length >= 3) {
                    // 是完整表格：表头 + 分隔线 + 数据行
                    const [header, separator, ...dataRows] = rows;
                    
                    // 解析对齐方式
                    const alignments = separator.map(cell => {
                        if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
                        if (cell.endsWith(':')) return 'right';
                        return 'left';
                    });
                    
                    let tableHtml = '<table>\n<thead>\n<tr>\n';
                    
                    // 表头
                    header.forEach((cell, i) => {
                        const align = alignments[i] || 'left';
                        tableHtml += `<th align="${align}">${processInlineMarkdown(cell)}</th>\n`;
                    });
                    
                    tableHtml += '</tr>\n</thead>\n<tbody>\n';
                    
                    // 数据行
                    dataRows.forEach(row => {
                        tableHtml += '<tr>\n';
                        row.forEach((cell, i) => {
                            const align = alignments[i] || 'left';
                            tableHtml += `<td align="${align}">${processInlineMarkdown(cell)}</td>\n`;
                        });
                        tableHtml += '</tr>\n';
                    });
                    
                    tableHtml += '</tbody>\n</table>';
                    return tableHtml;
                } else if (rows.length >= 1) {
                    // 简单表格（无表头分隔线）
                    let tableHtml = '<table>\n<tbody>\n';
                    
                    rows.forEach(row => {
                        tableHtml += '<tr>\n';
                        row.forEach(cell => {
                            tableHtml += `<td>${processInlineMarkdown(cell)}</td>\n`;
                        });
                        tableHtml += '</tr>\n';
                    });
                    
                    tableHtml += '</tbody>\n</table>';
                    return tableHtml;
                }
                
                return match;
            });
            
            // 3. 处理块级元素
            const lines = html.split('\n');
            let result = [];
            let inBlockquote = false;
            let inList = false;
            let listType = ''; // 'ul' or 'ol'
            let inPre = false;
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmed = line.trim();
                
                // 跳过已处理的代码块
                if (line.includes('<pre>')) {
                    inPre = true;
                    result.push(line);
                    continue;
                }
                if (line.includes('</pre>')) {
                    inPre = false;
                    result.push(line);
                    continue;
                }
                if (inPre) {
                    result.push(line);
                    continue;
                }
                
                // 跳过已处理的表格
                if (line.includes('<table>')) {
                    result.push(line);
                    // 找到表格结束
                    while (i < lines.length && !lines[i].includes('</table>')) {
                        i++;
                        if (i < lines.length) result.push(lines[i]);
                    }
                    continue;
                }
                
                // 处理标题
                if (trimmed.match(/^#{1,6}\s/)) {
                    const level = trimmed.match(/^(#{1,6})/)[1].length;
                    const title = trimmed.substring(level).trim();
                    result.push(`<h${level}>${processInlineMarkdown(title)}</h${level}>`);
                    continue;
                }
                
                // 处理水平线
                if (trimmed.match(/^[-*_]{3,}$/)) {
                    result.push('<hr>');
                    continue;
                }
                
                // 处理引用块
                if (trimmed.startsWith('>')) {
                    if (!inBlockquote) {
                        result.push('<blockquote>');
                        inBlockquote = true;
                    }
                    const content = trimmed.substring(1).trim();
                    result.push(`<p>${processInlineMarkdown(content)}</p>`);
                    
                    // 检查下一行是否还是引用
                    const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
                    if (!nextLine.startsWith('>')) {
                        result.push('</blockquote>');
                        inBlockquote = false;
                    }
                    continue;
                } else if (inBlockquote) {
                    result.push('</blockquote>');
                    inBlockquote = false;
                }
                
                // 处理列表
                const listMatch = trimmed.match(/^(\s*)([-*+]|\d+\.)\s+(.*)/);
                if (listMatch) {
                    const [, indent, marker, content] = listMatch;
                    const isOrdered = /^\d+\.$/.test(marker);
                    const currentListType = isOrdered ? 'ol' : 'ul';
                    const indentLevel = indent.length;
                    
                    // 检查任务列表
                    const taskMatch = content.match(/^\[(x| )\]\s+(.*)/i);
                    let listContent = content;
                    let checked = '';
                    
                    if (taskMatch) {
                        const [, check, task] = taskMatch;
                        checked = check.toLowerCase() === 'x' ? ' checked' : '';
                        listContent = `<label class="task-list-item">
                            <input type="checkbox" disabled${checked}>
                            <span>${processInlineMarkdown(task)}</span>
                        </label>`;
                    } else {
                        listContent = processInlineMarkdown(content);
                    }
                    
                    if (!inList || listType !== currentListType) {
                        if (inList) {
                            result.push(`</${listType}>`);
                        }
                        result.push(`<${currentListType}>`);
                        inList = true;
                        listType = currentListType;
                    }
                    
                    result.push(`<li>${listContent}</li>`);
                    
                    // 检查下一行是否还是列表
                    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
                    const nextListMatch = nextLine.match(/^(\s*)([-*+]|\d+\.)\s+/);
                    if (!nextListMatch) {
                        result.push(`</${listType}>`);
                        inList = false;
                        listType = '';
                    }
                    continue;
                } else if (inList) {
                    result.push(`</${listType}>`);
                    inList = false;
                    listType = '';
                }
                
                // 处理段落
                if (trimmed) {
                    // 合并连续的行为段落
                    let paragraph = trimmed;
                    let j = i + 1;
                    
                    while (j < lines.length) {
                        const nextTrimmed = lines[j].trim();
                        if (!nextTrimmed || 
                            nextTrimmed.match(/^#{1,6}\s|^[-*_]{3,}$|^>|^(\s*)([-*+]|\d+\.)\s+/) ||
                            lines[j].includes('<')) {
                            break;
                        }
                        paragraph += ' ' + nextTrimmed;
                        j++;
                    }
                    
                    i = j - 1;
                    result.push(`<p>${processInlineMarkdown(paragraph)}</p>`);
                } else {
                    // 空行
                    result.push('');
                }
            }
            
            // 清理并合并结果
            html = result.join('\n');
            
            // 清理空段落
            html = html.replace(/<p><\/p>/g, '');
            
            return html;
        }
        
        // 更新预览
        function updatePreview() {
            const content = document.getElementById('editor').value;
            document.getElementById('preview').innerHTML = parseMarkdown(content);
        }
        
        // 显示保存状态
        function showSaveStatus(message) {
            const status = document.getElementById('saveStatus');
            status.textContent = message;
            status.classList.add('show');
            
            setTimeout(() => {
                status.classList.remove('show');
            }, 2000);
        }
        
        // 保存文件
        async function saveFile() {
            const content = document.getElementById('editor').value;
            
            if (content === currentContent) {
                return; // 内容未改变，不保存
            }
            
            try {
                const response = await fetch(currentFile, {
                    method: 'PUT',
                    body: content,
                    headers: {
                        'Content-Type': 'text/markdown'
                    }
                });
                
                if (response.ok) {
                    currentContent = content;
                    showSaveStatus('已保存');
                } else {
                    showSaveStatus('保存失败');
                }
            } catch (error) {
                console.error('保存失败:', error);
                showSaveStatus('保存失败');
            }
        }
        
        // 开始自动保存计时
        function startAutoSave() {
            clearTimeout(saveTimer);
            saveTimer = setTimeout(saveFile, 5000); // 5秒后自动保存
        }
        
        // 加载文件
        async function loadFile(filename, isEditMode) {
            try {
                const response = await fetch(filename);
                
                if (response.ok) {
                    const content = await response.text();
                    
                    if (isEditMode) {
                        // 编辑模式
                        document.getElementById('editor').value = content;
                        currentContent = content;
                        updatePreview();
                        
                        // 设置编辑模式
                        document.getElementById('editMode').classList.remove('hidden');
                        document.getElementById('viewMode').classList.add('hidden');
                        
                        // 更新页面标题
                        document.title = `编辑: ${filename}`;
                    } else {
                        // 只读模式
                        document.getElementById('viewContent').innerHTML = parseMarkdown(content);
                        
                        // 设置只读模式
                        document.getElementById('viewMode').classList.remove('hidden');
                        document.getElementById('editMode').classList.add('hidden');
                        
                        // 更新页面标题
                        const firstLine = content.split('\n')[0] || filename;
                        const title = firstLine.replace(/^#\s*/, '');
                        document.title = title || '文档';
                    }
                    
                    currentFile = filename;
                    isEditing = isEditMode;
                    
                } else {
                    // 文件不存在
                    if (isEditMode) {
                        // 编辑模式下创建新文件
                        document.getElementById('editor').value = `# 新建文档\n\n开始编辑你的文档...`;
                        currentContent = document.getElementById('editor').value;
                        updatePreview();
                        
                        document.getElementById('editMode').classList.remove('hidden');
                        document.getElementById('viewMode').classList.add('hidden');
                        document.title = `新建: ${filename}`;
                        currentFile = filename;
                        isEditing = true;
                    } else {
                        // 查看模式下文件不存在，显示错误
                        document.getElementById('viewContent').innerHTML = 
                            '<h1>文件未找到</h1><p>请求的文件不存在：' + filename + '</p>';
                        document.getElementById('viewMode').classList.remove('hidden');
                        document.getElementById('editMode').classList.add('hidden');
                        document.title = '文件未找到';
                    }
                }
            } catch (error) {
                console.error('加载失败:', error);
                
                if (isEditMode) {
                    document.getElementById('editor').value = `# 加载失败\n\n无法加载文件: ${filename}\n\n请检查文件路径或网络连接。`;
                    currentContent = document.getElementById('editor').value;
                    updatePreview();
                    document.getElementById('editMode').classList.remove('hidden');
                    document.getElementById('viewMode').classList.add('hidden');
                } else {
                    document.getElementById('viewContent').innerHTML = 
                        '<h1>加载失败</h1><p>无法加载文件：' + filename + '</p><p>请检查文件路径或网络连接。</p>';
                    document.getElementById('viewMode').classList.remove('hidden');
                    document.getElementById('editMode').classList.add('hidden');
                }
            }
        }
        
        // 初始化
        function init() {
            // 解析URL参数
            const urlParams = new URLSearchParams(window.location.search);
            const editParam = urlParams.get('edit');
            const fileParam = urlParams.get('file');
            
            // 决定模式 - 默认加载 README.md（只读模式）
            if (editParam !== null) {
                // 编辑模式
                loadFile(editParam, true);
                
                // 设置编辑器事件
                const editor = document.getElementById('editor');
                editor.addEventListener('input', () => {
                    updatePreview();
                    startAutoSave();
                });
                
                editor.addEventListener('blur', saveFile);
            } else if (fileParam !== null) {
                // 只读模式（指定文件）
                loadFile(fileParam, false);
            } else {
                // 默认模式：加载 README.md（只读）
                loadFile('README.md', false);
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>